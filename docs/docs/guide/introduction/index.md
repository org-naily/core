# 介绍

**Naily** 是一个轻量的企业级 Web 框架，非常易于构建企业级的 Web 应用程序，并且完全开源。

Naily 出现的初衷，其实就是一堆人聚在一起，为了极致的、饱含各种终极 TypeScript 哲学的 CRUD 体验而出谋划策的人。

和 Naily 类似的框架有很多，比如：`Nest.js`，我们不满意的东西有很多，比如它的模块化系统。我们认为，模块化应该是**可选的**，而不是**必须的选择**，`@Module`很多时候是累赘，奈何`@Module`是`nest.js`的模块化哲学所在，如果用`nest`做项目，不得不就用这个，毕竟是模块化的一种可行的方案嘛。

所以`Naily`中仍然有这种类nest式的模块化方案，但是仅提供一个校验模块的作用，而不是`Naily容器`的必选项。毕竟有些时候我们只是想写一个简单的业务逻辑类，然后被自动扫描装配进去，而无需繁琐的模块化配置，也要进行`@Module`的装配，就非常令人感到繁琐。

## 核心概念

围绕着一个具体的业务类，有几个核心设计的点，这是大家公认的目标：

### 一切皆可注入

`@Injectable`走天下。在`Naily`中，一切类皆可注入，无需手动`New`一个类。`Naily`允许将多个类以最`轻量`的形式编织在一起，形成复杂的业务逻辑。

### Repository（仓库）

每次操作和读取一个类的方法或者属性，允许用户每次都创建一个新类（`PROTOTYPE`模式）或使用同一个类单例（`SINGLETON`模式），这个定义即为`Scope`（类的作用域）。而每个类的单例，会保存在这个`仓库`中，相当于一个缓冲池。

### Factory（工厂）

用来初始化类的类，就叫做`工厂`。

`工厂`和`仓库`紧密相连，这个`工厂`，整合了散落在各处的一堆JS原生API的各方法（比如`Reflect（反射）API`，`Object API`），并增强了它们的TS的类型。

通过`工厂`，我们可以拿到一个类的各种信息，比如类的`Token`，类的`Scope`，类的`方法、属性的键名列表`，等等。

而工厂最大的作用就是综合上面的各种信息，可以通过`工厂`来new一个类，将所有信息、注入，都装配上去。并且配合`仓库`，如果类是`SINGLETON`模式，则获取到的是缓存在`仓库`中的类；反之则每次都会创建一个新类。

以上两个概念是未来贯穿整个`Naily`生态的，无论在哪里，都能见到它俩。

其实，`工厂`和`仓库`是一个泛化的概念，`工厂`一般指的是`生产xxx的东西`，是`生产工具`；`仓库`是`存储xxx的东西`，是`存储工具`。任何`生产工具`和`存储工具`其实都可以称为`工厂`和`仓库`。因此在`后端`篇你还能看到`NailyWebFactory`等`工厂类`，他们也被称为`工厂`。
